<context:annotation-config/>
 is used to activate annotations in beans already registered in the application context (no matter if they were defined with XML or by package scanning).

<context:component-scan base-package = "com.vrtoonjava" />
scans packages to find and register beans within the application context.
-------------------------
Spring bean Scopes
by default : singleton,

prototype
<bean id="processor" class="com.LogProcessor" scope="prototype"/>

For annotation based bean, use below
@Scope("prototype")
public class CustomerService 
{ ....}
--------------------
Ref
https://www.mkyong.com/spring/spring-auto-scanning-components/
----------------
Stereotype annotation
@Component

@Controller
@Repository
@Service

---------
Annotating a class with the @Configuration indicates that the class can be used by the Spring IoC container as a source of bean definitions. 
The @Bean annotation tells Spring that a method annotated with @Bean will return an object that should be registered as a bean in the Spring 
application context

public static void main(String args[]) {
        AbstractApplicationContext context = new AnnotationConfigApplicationContext(HelloWorldConfig.class);
	 HelloWorld bean = (HelloWorld) context.getBean("helloWorldBean");
        bean.sayHello("Spring 4");
}	

AnnotationConfigApplicationContext creates Spring Application Context accepting input as our configuration class 
annotated with @Configuration, registering all the beans generated by the configuration class in Spring runtime. 
Once we got the context configured, we can use getBean method to fetch a specific bean from Spring application context 
and perform some action on that
--------------------
How to use stereotype based annotation using java based configuration.

Test.java
public static void main(String args[]) {
	AbstractApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
}	

AppConfig.java	
@Configuration
@ComponentScan("com.websystique.spring")
public class AppConfig 
{ ......}
=============================
--------
Method injection 
------------

Proxy scoped bean
another way to solve injecting a narrower scoped bean into wider scoped bean problem

http://stackoverflow.com/questions/14371335/spring-scoped-proxy-bean
http://www.logicbig.com/tutorials/spring-framework/spring-core/scoped-proxy/


Check 
<aop:scoped-proxy/>
-------------
Context aware

----------------
Spring Tool suite (STS)
Stateless and statefull bean
use singleton scope for statelesss bean
use prototype scopes for staefull bean

Context namespace is required for the application.properties file reference.

p namespace

<bean id="helloBeanTest" class="com.mkyong.core.HelloWorld">
	<constructor-arg index="0" value="Suresh123"/>
</bean>
// Instead of above , you can use
<bean id="helloBeanTest" class="com.mkyong.core.HelloWorld">
	<constructor-arg name="myName" value="Suresh123"/>
</bean>
//myName is the member variable.
	
<bean id="fruit" class="com.mkyong.core.Fruit">
	<property name="name" value="orange" />
</bean>


<bean id="fruitBean" class="com.mkyong.core.Fruit">
		<property name="fruitNameList">
			<list>
				<value>orange</value>
				<value>apple</value>
				<value>banana</value>
			</list>
		</property>
		
		<property name="fruitNameMap">
			<map>
				<entry key="apple" value="red"/>
				<entry key="banana" value="yello"/>
			</map>
		</property>
		
</bean>


Fruit as below member variables
private String name;
private List<String> fruitNameList;
private Map<String,String>fruitNameMap; 

<bean id="fruit" class="abc.fruit" p:myName="Suresh"/>

myName is member variable.


Inner bean
<bean id="mealOuterBean" class="food.Meal">
	<property name="fruit">
	<bean id="appleInnerBean" class="food.Apple">
		<property name="name" value="apple" />
		<property name="description" value="I am an apple. I am typically red or green with crisp flesh" />
	</bean>
	</property>
</bean> 

Some info....

value="${def-fruit}"

autowire="byType"
autowire="byName"
above uses setter methods

autowire using constructor

<bean id="grain" class="test.Grain" primary="true"></bean>
<bean id="grain2" class="test.Grain"></bean>

<bean id="meal" class="test.Meal" autowire="byType"/>


ClassPathXml


----------------
@ExceptionHandler({SpringException.class})
   public String addStudent( @ModelAttribute("HelloWeb")Student student, 
      ModelMap model) {

-------------
Spring bean life cycle

    InitializingBean and DisposableBean callback interfaces. //methods : afterPropertiesSet, destroy
    Other Aware interfaces for specific behaviour. //
    custom init() and destroy() methods in bean configuration file // example: ApplicationContextAware
		<bean id="abc" class="com.abcClass" init-method="testMethod"/>
    @PostConstruct and @PreDestroy annotations

----------------------

REST

@RestController
@RestController is a convenience annotation that does nothing more than adding the @Controller and @ResponseBody annotations.
added in spring 4
It eliminates the need of annotating each method with @ResponseBody

@RequestMapping
It is used to map web requests onto specific handler classes and/or handler methods. 


@RequestBody

======================

Spring 4 released in Dec 2013
Major changes in spring 4
> Deprecated methods, packages are dropped and no more support.
> Java 8 support
> Possible to define spring beans using Groovy DSL
> Spring core changes  (http://javabeat.net/spring-framework-4-0-features/)
  @Description : It provides a textual description of the bean 
  @Conditional
  Custom annotations : 
> Spring web module features
  below annotation is added.
  @RestController annotation for defining the REST web services. This has the built-in @ResponseBody attribute  
  Spring provides comprehensive timezone support when developing Spring MVC applications.
  
==============================

Check these things

AnnotationConfigApplicationContext ( http://websystique.com/spring/spring-4-hello-world-example-annotation-tutorial-full-example/)  
Persistence Context


================== REST ======================

@RestController
@RestController is a convenience annotation that does nothing more than adding the @Controller and @ResponseBody annotations.
added in spring 4
It eliminates the need of annotating each method with @ResponseBody

@RequestMapping
It is used to map web requests onto specific handler classes and/or handler methods. 


@RequestBody


Rest info.

@SpringBootApplication(scanBasePackages="com.mahesh.test")
public class RestAPIApp {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		SpringApplication.run(RestAPIApp.class, args); }}
		
@RestController
public class EmployeeController {

		@Autowired
		private EmployeeService service;
		
		@RequestMapping("/employees/")
		public List<Employee> getEmployeeList(){
			
				return service.getAllEmployee();
		}
		
		@RequestMapping("employees/{empid}")
		public Employee getEmployee(@PathVariable("empid") int eid) {
			
			return service.getEmployee(eid);
		}
		
		@RequestMapping(method=RequestMethod.POST,value="/addEmployee")
		public ResponseEntity<?> addEmployee(@RequestBody Employee emp, UriComponentsBuilder ucBuilder) {
			
			service.addEmployee(emp);
			
			 HttpHeaders headers = new HttpHeaders();
		     headers.setLocation(ucBuilder.path("/employees/{empid}").buildAndExpand(emp.getEid()).toUri());
		     return new ResponseEntity<String>(headers, HttpStatus.CREATED);
			
		}
}		
----------------------		



List of RESTful APIs
WSDL
WADL
CloudRail
API Blueprint
I/O Docs
Apache Avro

--------------------------------------

connector view in rest
Deploying a database to a server
Understanding cross-origin resource sharing
creating interfaces for utilizing the rest api
OAuth secure validation
Role based authorization
Securing an application by using OpenID Connect
Cache mechanism in REST
Create an OData Controller
Tracing in Web api
Using rest API in Node.js
