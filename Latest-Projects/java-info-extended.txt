Check
Implementation of String literal pool : Is it HashMap ?
enum
Garbage collector : Mark and sweep algorithm.
Class inside interface and viceversa.
=================================
Class loader
Java memory model
memory management
different types of memory area.
garbage collector

Method area
Delegation hierarchy principle



java.security package

url
http://www.sanfoundry.com/java-mcqs-thread-class/
http://www.sanfoundry.com/java-mcqs-core-java-api-packages/


------------------------

java.lang.reflect.ReflectPermission (it extends java.security.BasicPermission)
above class allows us to get real time data about private and protected member of a class
-------------------------

Class loader 

java.lang.ClassLoader  (Its an abstract class)

Class loader sub sytem(CLSS) follows particular algorithm. ie Delegation hierarchy algorithm.

1)Whenever jvm come across particular java class, jvm checks this class file is already loaded or not in method area.
2) If .class file is not loaded, then jvm delegates(requests)CLSS to load the class file.
3) CLSS forwards the request to application class loader(ACL). ACL delegates to extension class loader. Extension class loader
delegates request to Bootstrap class loader.
4) Bootstrap class loader tries to find the class file in the bootstrap class path. (ie JDK/JRE/LIB/*.jar)ie rt.jar
5) If file in above path, it loads that file.
6) If not present, then Bootstrap class loader delegates to Ext. class loader. It searches in extension class path(ie JDK/JRE/LIB/EXT/*.jar)
7) If not present, then ext. delegates back request to application class loader. It searches in application class path.
8) If not present in app. class path, then we get runtime exception : ClassNotFoundException

------------ 
Different types of classLoaders.


Extension ClassLoader in JVM is implemented by  sun.misc.Launcher$ExtClassLoader. 

Application class loader is a child of Extension ClassLoader and its implemented by sun.misc.Launcher$AppClassLoader class
--------------------
How to load the class explicitly in java

Ans: Class.forName("com.mahesh.test")

--------------
Class Self reference

When a java source file is compiled to a binary class, compiler inserts a field into java class file. It is a public static final field named ‘class’ of type java.lang.Class

So for all java classes you can access it as java.lang.Class classObj = ClassName.class;

Significance of this Class object is it contains a method getClassLoader() which returns the class loader for the class. It will return null it it was loaded by bootstrap class loader.

====================================

JVM Architecture

.class file is input to class loader subsystem.

Part 1:
Class Loader sub system has 3 parts(Modules).
1) Loading : (It has 3 parts. Bootstrap class loader, Extension, Application class loader. Uses : Delegatin Hierarchy algorithm.)
2) Linking : It has 3parts. 1) Verify 2) Prepare. 3) Resolve.
	     Verify : Bytecode verifier going to verify whether generated bytecode is proper or not. generated by valid compiler or not.Is it
		      virus or not.
	     Prepare : For static variables, memory will be allocated and assinged with default values. 
	     Resolve : All symbolic references are replaced with original references from method area.

3) Initialization  : For static variables, original values are assigned. static blocks will be exceuted.


Part 2: 
To load a class and to execute , memory is required.
Various memory areas present inside JVM
1. Method Area : Class level data will be present. (.class file is dumped to this area. Static variable also saved here.) 
                 It includes PermGen space.
2. Heap memory : Objects data will be saved. 
3. Stack area : For every thread, run time stack memory is created.
4. PC registers : For every thread, separate pc register will be created. (To hold address of current executing instructions.)
5. Native method stack : For every thread, a separate native method stack is created. (To hold native method info.)

Part 3: 
Execution engine : Is responsible for executing the program. Executing line by line.
It has 3 parts
1. Interpreter
2. JIT compiler : 
3. Garbage collector.

=====================================
String literal pool uses PermGen space memory area.  But from java 7 onwards it uses Heap memory.
PermGen space is part of Method area.
PermGen space is replaced by Metaspace in jdk8
Class related info. is saved in Metaspace. 
===========================
Garbage collection

It works on heap memory.
Hotspot heap structure

Young generation : It has Eden, Survivor space(S0,S1)
Old generation :  It has Tenured
Permanent generation : PermGen

==============================
Enum

A Java Enum is a special Java type used to define collections of constants. 
More precisely, a Java enum type is a special kind of Java class. 
An enum can contain constants, methods etc. Java enums were added in Java 5. 

